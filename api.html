<html>

<style>
.pad {
    padding: 0.3em 2em;
}

.quickStart {
  background: beige;
  border-radius: 1em;
}


.links li {
  display: inline;
  background: beige;
  padding: 0.3em 1em;
  margin-right: 1em;
  border-radius: .3em;
  border: 1px dotted grey;
}

.links a {
  text-decoration: none;
}
</style>

<body>

<div class="quickStart pad" >
<h2>Quick Start</h2>

<h3>Step 1: Drop the script on your page</h3>
<pre>
&lt;script src="flif.js"&gt;&lt;/script&gt;
</pre>
<p>The script can be downloaded from the <a href="https://github.com/UprootLabs/poly-flif/releases">release</a> page.</p>

<h3>Step 2: Add a canvas element where you need the FLIF image to appear</h3>
<pre>
&lt;canvas data-polyflif-src="xyz.flif"&gt;&lt;/canvas&gt;
</pre>

<h3>Step 3: <strike>? ? ? ?</strike> Watch the image load and render</h3>

<h3>Step 4: Profit</h3>
The decoder is LGPLv3 licensed. The code is on <a href="https://github.com/UprootLabs/poly-flif">GitHub</a>.
</div>

<hr />

<ul class="links pad">
<li> <a href='polyflif-sample.html'>Sample Page</a> </li>
<li> <a href='index.html'>Interactive demo</a> </li>
<li> <a href='http://flif.info'>About FLIF</a> </li>
</ul>

<div class="pad">
<h2>Documentation</h2>

<h3>Basics</h3>
The `flif.js` script performs the following steps:

<ol>
<li>Registers a handler for `DOMContentLoaded` event.</li>
<li>When the event is triggered, it queries all canvas elements that have `data-polyflif-src` attribute.</li>
<li>Each such &lt;canvas&gt; element will be queued for processing.</li>
<li>The URL specified in the attribute will be loaded via XHR request, decoded and rendered onto the canvas.</li>
</ol>

The canvas element will be resized to fit the image dimensions.

Similarly, if any element has the `data-polyflif-bg-src` attribute, then the CSS `background-image` is set to the decoded
FLIF image.

<h3>Partial load and decode</h3>
<p>
A FLIF image can be partially decoded to yield a lower resolution image. We can utilise this to reduce bandwidth and CPU usage.
</p>
<p>Use the optional `data-polyflif-bytes` attribute to specify the amount of bytes to be loaded and decoded. When this is specified,
a range header is added to the XHR request. If the server supports range requests, only the specified bytes will be loaded.
Further, the data from XHR, if not truncated by the server, will be truncated in JS to ensure that decoding is partial.</p>

<p>Tip: To determine the optimal number of bytes to decode, use the CLI tool with the <em>-b</em> option.</p>

<h3>Controlling the image dimensions</h3>
<p>
First, style the canvas element using CSS so that it has the desired dimensions. You can use media-queries to set responsive dimensions.
</p>

<p>
Then, add the `data-polyflif-scale` attribute to the canvas element. When this attribute is present, the CSS computed size of the canvas
element is sent to the decoder (equivalent to the <em>-f</em> option of the FLIF CLI tool). The image is decoded so that it fits the requested
dimensions.
</p>

<p>
(We need to add more options here, for example, to center the image in the canvas, to upscale the image, resize the canvas to fit
actual dimensions, etc).
</p>

<h3>Low Level API</h3>

Example usage:

<pre>
var canvasElement = document.getElementById("...");    // get canvas element somehow
var buffer = ...                                       // get data in Uint8Array; via XHR, for example.

var options = {
  canvas: canvasElement,
  buf:    buffer
};
var pf = new PolyFlif(options);

var truncationPercent = 0;                            // in percent (0 to 100). 0 means no truncation.
var truncationCount = -1;                             // in bytes (-1 means no truncation)
var rw = 0;                                           // requested width (if 0, original image width is used)
var rh = 0;                                           // requested height (if 0, original image height is used)

// Either this version
pf.beginPercent(truncationPercent, rw, rh);

// Or this version
pf.beginCount(truncationCount, rw, rh);
</pre>

</div>

</body>

</html>
